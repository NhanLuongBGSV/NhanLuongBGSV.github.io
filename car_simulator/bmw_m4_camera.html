<!DOCTYPE html>
<html lang="en">

<head>
	<title>Three.js M4 BMW</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		body {
			color: #bbbbbb;
			background: #333333;
		}

		a {
			color: #08f;
		}

		.colorPicker {
			display: inline-block;
			margin: 0 10px
		}

		.smallBtn {
			cursor: pointer;
			width: 60px;
			height: 22px;
			background-color: #ABABABBB;
			border-radius: 4px;
			text-align: center;
			font-size: 14px;
			line-height: 20px;
		}

		.largeBtn {
			display:inline-block;
			cursor:pointer;
			width:60px;
			height:32px;
			background-color: #ABABABBB;
			border-radius:6px;
			text-align:center;
			font-size:14px;
			line-height: 30px;
		}
	</style>
</head>

<body>
	<div id="info">
		<div style="font-size:16px;margin-top:2px;">
			It will take a few seconds to load the car model, please be patient.
		</div>
		<div style="display:none;">
			<span class="colorPicker"><input id="body-color" type="color" value="#ff0000"></input><br />Body</span>
			<span class="colorPicker"><input id="details-color" type="color"
					value="#ffffff"></input><br />Details</span>
			<span class="colorPicker"><input id="glass-color" type="color" value="#ffffff"></input><br />Glass</span>
		</div>
	</div>
	<div id="container"></div>

	<div
		style="display:none;color:white;user-select: none;position:fixed;z-index:9;bottom:4px;left:4px;padding:8px;border-radius: 8px;">
		<div id="positionState"></div>
		<div style="display: grid;grid-template-columns: repeat(3, 1fr);grid-gap: 2px;">
			<div class="smallBtn" id="posXInc">X+</div>
			<div class="smallBtn" id="posYInc">Y+</div>
			<div class="smallBtn" id="posZInc">Z+</div>
			<div class="smallBtn" id="posXDec">X-</div>
			<div class="smallBtn" id="posYDec">Y-</div>
			<div class="smallBtn" id="posZDec">Z-</div>
		</div>
		<div style="display: grid;grid-template-columns: repeat(3, 1fr);grid-gap: 2px;margin-top:10px;">
			<div class="smallBtn" id="ctrlXInc">X+</div>
			<div class="smallBtn" id="ctrlYInc">Y+</div>
			<div class="smallBtn" id="ctrlZInc">Z+</div>
			<div class="smallBtn" id="ctrlXDec">X-</div>
			<div class="smallBtn" id="ctrlYDec">Y-</div>
			<div class="smallBtn" id="ctrlZDec">Z-</div>
		</div>
	</div>

	<div
		style="color:white;user-select: none;position:fixed;z-index:9;bottom:4px;right:-20px;padding:8px;display:inline-block;display: grid;grid-template-columns: repeat(2, 1fr);grid-gap: 4px;;background-color: #ffffff00;border-radius: 8px;;">
		<div id="btnReset" class="largeBtn" style="width:90px; font-size:12px;">
			Reset View
		</div>
		<div id="btnForward" class="largeBtn"
			style="background-color: #0088FFFF;">
			▲
		</div>
		<div id="btnDriver" class="largeBtn" style="width:90px;font-size:12px;">
			Driver View
		</div>
		<!-- <div id="btnLeft" style="display:inline-block;cursor:pointer;width:60px;height:32px;background-color: #0088FFFF;border-radius:6px;text-align:center;font-size:24px;line-height: 30px;">
			◀
		</div> -->
		<div id="btnBackward" class="largeBtn"
			style="background-color: #0088FFFF;">
			▼
		</div>
		<!-- <div id="btnRight" style="display:inline-block;cursor:pointer;width:60px;height:32px;background-color: #0088FFFF;border-radius:6px;text-align:center;font-size:24px;line-height: 30px;">
			▶
		</div> -->
	</div>

	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

	<script type="importmap">
			{
				"imports": {
					"three": "./three/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

	<script type="module">

		const round1Dec = (num) => {
			return Math.round(num * 10) / 10
		}

		import * as THREE from 'three';

		import Stats from 'three/addons/libs/stats.module.js';

		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
		import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

		let camera, scene, renderer;
		let stats;

		let grid;
		let controls;

		let cameraX = 0;
		let cameraY = 0;
		let cameraZ = 0;

		let controlX = 0;
		let controlY = 0;
		let controlZ = 0;

		const wheels = [];

		let speed = 0;

		let driver_door = null;
		let DRIVER_DOOR_ANGLE_OPEN = Math.PI / 2 - Math.PI / 3;
		let DRIVER_DOOR_ANGLE_CLOSE = Math.PI / 2;
		let driver_door_angle = DRIVER_DOOR_ANGLE_CLOSE;

		let seats = null;
		let seats_position = 0;
		let SEATS_MIN = -3.68 + 10;
		let SEATS_MAX = -3.68 - 7;

		let camIndex = 1000;

		let cameraPositions = [
			{ x: 7.5, y: 3, z: -2.2 },
			{ x: 2, y: 3, z: -2.2 },
		]

		let initPositions = { x: 25, y: 2, z: -16 }
		let driver_poisition = { x: 0.3, y: 1.6, z: -0.25 }

		setInterval(() => {
			if (!camera) return
			if (camIndex < cameraPositions.length - 1) {
				camera.position.set(cameraPositions[camIndex].x, cameraPositions[camIndex].y, cameraPositions[camIndex].z);
				camIndex++;
			}
		}, 100);

		setInterval(() => {
			if (!parent) return
			parent.postMessage(JSON.stringify({ viewer: { cameraPosition: camera.position } }), '*')
		}, 1000)

		const moveForward = () => {
			if (!camera) return
			camera.position.set(camera.position.x - 0.5,
				camera.position.y,
				camera.position.z + 0.35);
		}
		const moveBackward = () => {
			if (!camera) return
			camera.position.set(camera.position.x + 0.5,
				camera.position.y,
				camera.position.z - 0.35);
		}
		const toLeft = () => {
			if (!camera) return
			camera.position.set(camera.position.x - 0.1,
				camera.position.y,
				camera.position.z + 0.2);
		}
		const toRight = () => {
			if (!camera) return
			camera.position.set(camera.position.x + 0.1,
				camera.position.y,
				camera.position.z - 0.2);
		}

		const resetView = () => {
			if (!camera) return
			camera.position.set(initPositions.x, initPositions.y, initPositions.z);
			seats_position = SEATS_MIN
			driver_door_angle = DRIVER_DOOR_ANGLE_CLOSE
			controls.target.set(0, 0.5, 0);
		}

		const setInsideView = () => {
			// camera.position.set(0.3, 1.6,-0.25);
			camera.position.set(driver_poisition.x, driver_poisition.y, driver_poisition.z);
			controls.target.set(0.3, -6.4, 33.4);
			// controls.setPolarAngle(Math.PI/2);
			// controls.setAzimuthalAngle(Math.PI/5);/
		}
		let positionState = document.getElementById('positionState')
		let posXInc = document.getElementById('posXInc')
		let posXDec = document.getElementById('posXDec')
		let posYInc = document.getElementById('posYInc')
		let posYDec = document.getElementById('posYDec')
		let posZInc = document.getElementById('posZInc')
		let posZDec = document.getElementById('posZDec')

		posXInc.addEventListener("click", function (e) {
			camera.position.x += 0.2
		})
		posXDec.addEventListener("click", function (e) {
			camera.position.x -= 0.2
		})

		posYInc.addEventListener("click", function (e) {
			camera.position.y += 0.2
		})
		posYDec.addEventListener("click", function (e) {
			camera.position.y -= 0.2
		})

		posZInc.addEventListener("click", function (e) {
			camera.position.z += 0.2
		})
		posZDec.addEventListener("click", function (e) {
			camera.position.z -= 0.2
		})

		let ctrlXInc = document.getElementById('ctrlXInc')
		let ctrlXDec = document.getElementById('ctrlXDec')
		let ctrlYInc = document.getElementById('ctrlYInc')
		let ctrlYDec = document.getElementById('ctrlYDec')
		let ctrlZInc = document.getElementById('ctrlZInc')
		let ctrlZDec = document.getElementById('ctrlZDec')

		ctrlXInc.addEventListener("click", function (e) {
			controls.target.x += 0.2
		})
		ctrlXDec.addEventListener("click", function (e) {
			controls.target.x -= 0.2
		})

		ctrlYInc.addEventListener("click", function (e) {
			controls.target.y += 0.2
		})
		ctrlYDec.addEventListener("click", function (e) {
			controls.target.y -= 0.2
		})

		ctrlZInc.addEventListener("click", function (e) {
			controls.target.z += 0.2
		})
		ctrlZDec.addEventListener("click", function (e) {
			controls.target.z -= 0.2
		})



		let btnReset = document.getElementById('btnReset');
		let btnForward = document.getElementById('btnForward');
		let btnDriver = document.getElementById('btnDriver');
		// let btnLeft = document.getElementById('btnLeft');
		let btnBackward = document.getElementById('btnBackward');
		// let btnRight = document.getElementById('btnRight');

		btnReset.addEventListener("click", function (e) {
			resetView()
		})
		btnDriver.addEventListener("click", function (e) {
			setInsideView()
		})

		let isForwardPressed = false
		let isBackardPressed = false
		let isLeftPressed = false
		let isRightPressed = false

		setInterval(() => {
			if (isForwardPressed) {
				moveForward()
			}
			if (isBackardPressed) {
				moveBackward()
			}
			if (isLeftPressed) {
				toLeft()
			}
			if (isRightPressed) {
				toRight()
			}
		}, 300);

		btnForward.addEventListener("click", function (e) {
			moveForward()
		})

		btnForward.onpointerdown = function () {
			isForwardPressed = true;
		}
		btnForward.onpointerup = function () {
			isForwardPressed = false;
		}

		btnBackward.addEventListener("click", function (e) {
			moveBackward()
		})
		btnBackward.onpointerdown = function () {
			isBackardPressed = true;
		}
		btnBackward.onpointerup = function () {
			isBackardPressed = false;
		}

		function setDriverDoorAngle(angle) {
			driver_door_angle = angle
		}

		function openDriverDoor() {
			if (driver_door_angle === DRIVER_DOOR_ANGLE_OPEN) return;
			driver_door_angle = DRIVER_DOOR_ANGLE_CLOSE;
			for (let i = 0; i < 10; i++) {
				setTimeout(() => {
					driver_door_angle += (DRIVER_DOOR_ANGLE_OPEN - DRIVER_DOOR_ANGLE_CLOSE) / 10;
				}, i * 100);
			}
		}

		function closeDriverDoor() {
			if (driver_door_angle === DRIVER_DOOR_ANGLE_CLOSE) return;
			driver_door_angle = DRIVER_DOOR_ANGLE_OPEN;
			driver_door.rotation.y = driver_door_angle;
			for (let i = 0; i < 10; i++) {
				setTimeout(() => {
					driver_door_angle -= (DRIVER_DOOR_ANGLE_OPEN - DRIVER_DOOR_ANGLE_CLOSE) / 10;
					driver_door.rotation.y = driver_door_angle;
				}, i * 100);
			}
		}

		function expandSeats() {
			if (seats_position === SEATS_MAX) return;
			seats_position = SEATS_MIN;
			for (let i = 0; i < 10; i++) {
				setTimeout(() => {
					seats_position += (SEATS_MAX - SEATS_MIN) / 10;
				}, i * 100);
			}
		}

		function closeSeats() {
			if (seats_position === SEATS_MIN) return;
			seats_position = SEATS_MAX;
			for (let i = 0; i < 10; i++) {
				setTimeout(() => {
					seats_position -= (SEATS_MAX - SEATS_MIN) / 10;
				}, i * 100);
			}
		}

		function init() {

			const container = document.getElementById('container');

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setAnimationLoop(render);
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.toneMappingExposure = 0.85;
			container.appendChild(renderer.domElement);

			window.addEventListener('resize', onWindowResize);

			window.addEventListener("message", function (e) {
				if (!e.data) return
				// console.log(e.data)
				let payload = JSON.parse(e.data)
				// console.log(payload.driver_door_angle)
				if (payload.driver_door_angle !== undefined) {
					setDriverDoorAngle(Number(payload.driver_door_angle))
				}

				if (payload.cmd) {
					switch (payload.cmd) {
						case 'open_driver_door':
							openDriverDoor()
							break;
						case 'close_driver_door':
							closeDriverDoor()
							break;
						case 'expand_seats':
							expandSeats()
							break;
						case 'close_seats':
							closeSeats()
							break;
						case 'move_forward':
							moveForward()
							break;
						case 'move_backward':
							moveBackward()
							break;
						case 'move_camera':
							if (payload.from && payload.to && payload.step) {
								cameraPositions = []
								let xChange = (payload.to.x - payload.from.x) / payload.step
								let yChange = (payload.to.y - payload.from.y) / payload.step
								let zChange = (payload.to.z - payload.from.z) / payload.step
								for (let i = 0; i < payload.step; i++) {
									cameraPositions.push({
										x: payload.from.x + i * xChange,
										y: payload.from.y + i * yChange,
										z: payload.from.z + i * zChange
									})
								}
							}
							camIndex = 0;
							break;
						case 'reset':
							resetView()
							break;

						default:
							break;
					}
				}
			}, false);

			stats = new Stats();
			container.appendChild(stats.dom);

			//

			let camFOV = 48 // angle
			let camAspectRatio = window.innerWidth / window.innerHeight
			let canNEAR = 0.1
			let camFAR = 100

			camera = new THREE.PerspectiveCamera(camFOV, camAspectRatio, canNEAR, camFAR);
			window.camera = camera
			// camera.position.set( 4.25, 1.4, - 4.5 );
			camera.position.set(initPositions.x, initPositions.y, initPositions.z);

			controls = new OrbitControls(camera, container);
			controls.maxDistance = 40;
			controls.maxPolarAngle = THREE.MathUtils.degToRad(90);
			controls.target.set(0, 0.5, 0);
			controls.update();
			window.controls = controls

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0x333333);
			scene.environment = new RGBELoader().load('textures/venice_sunset_1k.hdr');
			scene.environment.mapping = THREE.EquirectangularReflectionMapping;
			scene.fog = new THREE.Fog(0x333333, 13, 60);

			grid = new THREE.GridHelper(60, 120, 0xffffff, 0xffffff);
			grid.material.opacity = 0.2;
			grid.material.depthWrite = false;
			grid.material.transparent = true;
			scene.add(grid);

			const geometry = new THREE.TorusGeometry(8, 0.1, 2, 100);
			const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
			geometry.rotateX(Math.PI / 2)
			const torus = new THREE.Mesh(geometry, material);
			scene.add(torus);

			// materials

			const bodyMaterial = new THREE.MeshPhysicalMaterial({
				color: 0xff0000, metalness: 1.0, roughness: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.03
			});

			const detailsMaterial = new THREE.MeshStandardMaterial({
				color: 0xffffff, metalness: 1.0, roughness: 0.5
			});

			const glassMaterial = new THREE.MeshPhysicalMaterial({
				color: 0xffffff, metalness: 0.25, roughness: 0, transmission: 1.0
			});

			const bodyColorInput = document.getElementById('body-color');
			bodyColorInput.addEventListener('input', function () {

				bodyMaterial.color.set(this.value);

			});

			const detailsColorInput = document.getElementById('details-color');
			detailsColorInput.addEventListener('input', function () {

				detailsMaterial.color.set(this.value);

			});

			const glassColorInput = document.getElementById('glass-color');
			glassColorInput.addEventListener('input', function () {

				glassMaterial.color.set(this.value);

			});

			// Car

			const shadow = new THREE.TextureLoader().load('models/ferrari_ao.png');

			const dracoLoader = new DRACOLoader();
			dracoLoader.setDecoderPath('jsm/gltf/');

			const loader = new GLTFLoader();
			loader.setDRACOLoader(dracoLoader);

			loader.load('models/bmw_m4.glb', function (gltf) {

				const carModel = gltf.scene.children[0];

				driver_door = carModel.getObjectByName('Driver_Door')
				seats = carModel.getObjectByName('seats')
				seats_position = Number(SEATS_MIN)

				// shadow
				const mesh = new THREE.Mesh(
					new THREE.PlaneGeometry(0.655 * 4, 1.3 * 4),
					new THREE.MeshBasicMaterial({
						map: shadow, blending: THREE.MultiplyBlending, toneMapped: false, transparent: true
					})
				);
				// mesh.rotation.x = - Math.PI / 2;
				// mesh.rotation.x = - Math.PI / 2;
				mesh.renderOrder = 2;
				carModel.add(mesh);

				scene.add(carModel);

			});

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function render() {

			controls.update();

			if (driver_door) {
				driver_door.rotation.y = driver_door_angle;
			}

			if (seats) {
				seats.position.z = seats_position
			}

			renderer.render(scene, camera);

			stats.update();

			cameraX = camera.position.x;
			cameraY = camera.position.y;
			cameraZ = camera.position.z;

			controlX = controls.target.x;
			controlY = controls.target.y;
			controlZ = controls.target.z;

			let distanceToDriver = Math.abs(cameraX-driver_poisition.x)+Math.abs(cameraY-driver_poisition.y)+Math.abs(cameraZ-driver_poisition.z)

			if(distanceToDriver < 3 && distanceToDriver>1) {
				setInsideView()
			}

			positionState.innerText = `CAM: ${round1Dec(cameraX)} ${round1Dec(cameraY)} ${round1Dec(cameraZ)} | CONTROL: ${round1Dec(controlX)} ${round1Dec(controlY)} ${round1Dec(controlZ)}`

		}

		init();

	</script>

</body>

</html>